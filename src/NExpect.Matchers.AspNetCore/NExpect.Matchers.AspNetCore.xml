<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NExpect.Matchers.AspNetCore</name>
    </assembly>
    <members>
        <member name="T:NExpect.AspNetCoreExpectations">
            <summary>
            Adds AspNetCore convenience expectations around collection-like
            types
            </summary>
        </member>
        <member name="M:NExpect.AspNetCoreExpectations.Expect(Microsoft.AspNetCore.Http.IFormFileCollection)">
            <summary>
            Treat an IFormFileCollection like a collection of IFormFile
            </summary>
            <param name="files"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.AspNetCoreExpectations.Expect(Microsoft.AspNetCore.Http.IFormCollection)">
            <summary>
            Treat an IFormCollection like a collection of KeyValuePair&lt;string, StringValues&gt;
            </summary>
            <param name="form"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.AspNetCoreExpectations.Expect(Microsoft.AspNetCore.Http.IHeaderDictionary)">
            <summary>
            Treat an IHeaderDictionary like an IDictionary&lt;string, StringValues&gt;
            </summary>
            <param name="headers"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.AspNetCoreExpectations.Expect(Microsoft.AspNetCore.Http.HeaderDictionary)">
            <summary>
            Treat an IHeaderDictionary like an IDictionary&lt;string, StringValues&gt;
            </summary>
            <param name="headers"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.AspNetCoreExpectations.Expect(Microsoft.AspNetCore.Http.IRequestCookieCollection)">
            <summary>
            Treat an IRequestCookieCollection like a collection of KeyValuePair&lt;string, string&gt;
            </summary>
            <param name="cookies"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.AspNetCoreExpectations.Expect(Microsoft.AspNetCore.Http.IQueryCollection)">
            <summary>
            Treat an IQueryCollection like a collection of KeyValuePair&lt;string, string&gt;
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="T:NExpect.ControllerMatchers">
            <summary>
            Adds matchers for AspNetCore Controllers and Controller Actions
            </summary>
        </member>
        <member name="M:NExpect.ControllerMatchers.Method(NExpect.Interfaces.IHave{System.Type},System.String)">
            <summary>
            Asserts that the controller has the named method
            </summary>
            <param name="have"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.ControllerMatchers.Route(NExpect.Interfaces.IHave{System.Type},System.String)">
            <summary>
            Asserts that the controller has the expected base route
            </summary>
            <param name="have"></param>
            <param name="expected"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.ControllerMatchers.Route(NExpect.Interfaces.IHave{System.Type},System.String,System.String)">
            <summary>
            Quick-n-dirty assertion that a controller's method has the required route
            </summary>
            <param name="have"></param>
            <param name="member"></param>
            <param name="expected"></param>
            <returns></returns>
        </member>
        <member name="T:NExpect.ControllerMatchers.SupportingExtension">
            <summary>
            Provides fluency for Supporting()
            </summary>
        </member>
        <member name="M:NExpect.ControllerMatchers.SupportingExtension.Supporting(System.Net.Http.HttpMethod)">
            <summary>
            Asserts that the controller method being operated on supports
            the desired HttpMethod
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="P:NExpect.ControllerMatchers.SupportingExtension.With">
            <summary>
            Fluency extension
            </summary>
        </member>
        <member name="P:NExpect.ControllerMatchers.SupportingExtension.And">
            <summary>
            Fluency extension
            </summary>
        </member>
        <member name="M:NExpect.ControllerMatchers.SupportingExtension.Route(System.String)">
            <summary>
            Asserts that the controller action being operated on has the specified route
            </summary>
            <param name="expected"></param>
            <returns></returns>
        </member>
        <member name="T:NExpect.ControllerMatchers.AndSupportingExtension">
            <summary>
            Fluency extension
            </summary>
        </member>
        <member name="P:NExpect.ControllerMatchers.AndSupportingExtension.With">
            <summary>
            Fluency extension
            </summary>
        </member>
        <member name="M:NExpect.ControllerMatchers.AndSupportingExtension.And(System.Net.Http.HttpMethod)">
            <summary>
            Asserts that the controller method being operated on has an
            additional supported HttpMethod
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:NExpect.HttpResponseMessageMatchers">
            <summary>
            Provides matchers for HttpResponseMessages
            </summary>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Cookie(NExpect.Interfaces.IHave{System.Net.Http.HttpResponseMessage},System.String)">
            <summary>
            Tests if an HttpResponseMessage contains the Set-Cookie
            header that would set the cookie with the provided name
            </summary>
            <param name="have"></param>
            <param name="name"></param>
            <returns>Continuation to further test the cookie, if found</returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Cookie(NExpect.Interfaces.IHave{System.Net.Http.HttpResponseMessage},System.String,System.String)">
            <summary>
            Tests if an HttpResponseMessage contains the Set-Cookie
            header that would set the cookie with the provided name
            </summary>
            <param name="have"></param>
            <param name="name"></param>
            <param name="customMessage"></param>
            <returns>Continuation to further test the cookie, if found</returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Cookie(NExpect.Interfaces.IHave{System.Net.Http.HttpResponseMessage},System.String,System.Func{System.String})">
            <summary>
            Tests if an HttpResponseMessage contains the Set-Cookie
            header that would set the cookie with the provided name
            </summary>
            <param name="have"></param>
            <param name="name"></param>
            <param name="customMessageGenerator"></param>
            <returns>Continuation to further test the cookie, if found</returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Value(NExpect.Interfaces.IWith{System.Net.Cookie},System.String)">
            <summary>
            Tests that a cookie has the expected value
            </summary>
            <param name="with"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Value(NExpect.Interfaces.IWith{System.Net.Cookie},System.String,System.String)">
            <summary>
            Tests that a cookie has the expected value
            </summary>
            <param name="with"></param>
            <param name="value"></param>
            <param name="customMessage"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Value(NExpect.Interfaces.IWith{System.Net.Cookie},System.String,System.Func{System.String})">
            <summary>
            Tests that a cookie has the expected value
            </summary>
            <param name="with"></param>
            <param name="value"></param>
            <param name="customMessageGenerator"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Secure(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie})">
            <summary>
            Tests if the cookie has the Secure flag
            </summary>
            <param name="more"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Secure(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie},System.String)">
            <summary>
            Tests if the cookie has the Secure flag
            </summary>
            <param name="more"></param>
            <param name="customMessage"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Secure(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie},System.Func{System.String})">
            <summary>
            Tests if the cookie has the Secure flag
            </summary>
            <param name="more"></param>
            <param name="customMessageGenerator"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.HttpOnly(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie})">
            <summary>
            Tests if the cookie has the HttpOnly flag
            </summary>
            <param name="more"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.HttpOnly(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie},System.String)">
            <summary>
            Tests if the cookie has the HttpOnly flag
            </summary>
            <param name="more"></param>
            <param name="customMessage"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.HttpOnly(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie},System.Func{System.String})">
            <summary>
            Tests if the cookie has the HttpOnly flag
            </summary>
            <param name="more"></param>
            <param name="customMessageGenerator"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Domain(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie},System.String)">
            <summary>
            Tests if the cookie has the Domain flag
            </summary>
            <param name="more"></param>
            <param name="expectedDomain"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Domain(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie},System.String,System.String)">
            <summary>
            Tests if the cookie has the Domain flag
            </summary>
            <param name="more"></param>
            <param name="expectedDomain"></param>
            <param name="customMessage"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Domain(NExpect.Interfaces.ICanAddMatcher{System.Net.Cookie},System.String,System.Func{System.String})">
            <summary>
            Tests if the cookie has the Domain flag
            </summary>
            <param name="more"></param>
            <param name="expectedDomain"></param>
            <param name="customMessageGenerator"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Age(NExpect.Interfaces.IMax{System.Net.Cookie},System.Int32)">
            <summary>
            Tests if the cookie has the Age flag
            </summary>
            <param name="more"></param>
            <param name="expectedAge"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Age(NExpect.Interfaces.IMax{System.Net.Cookie},System.Int32,System.String)">
            <summary>
            Tests if the cookie has the Age flag
            </summary>
            <param name="more"></param>
            <param name="expectedAge"></param>
            <param name="customMessage"></param>
            <returns></returns>
        </member>
        <member name="M:NExpect.HttpResponseMessageMatchers.Age(NExpect.Interfaces.IMax{System.Net.Cookie},System.Int32,System.Func{System.String})">
            <summary>
            Tests if the cookie has the Age flag
            </summary>
            <param name="more"></param>
            <param name="expectedAge"></param>
            <param name="customMessageGenerator"></param>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.AutoLocker">
            <summary>
            Class to use the using() {} pattern to take care of locking / unlocking one of:
            - Semaphore
            - SemaphoreSlim
            - Mutex
            without the consumer having to worry about unlocking in the event of exception
            handling
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.AutoLocker.#ctor(System.Threading.Semaphore)">
            <summary>
            Constructs a new AutoLocker, immediately locking the provided Semaphore
            </summary>
            <param name="semaphore">Semaphore to lock immediately</param>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if the provided Semaphore is null</exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.AutoLocker.#ctor(System.Threading.SemaphoreSlim)">
            <summary>
            Constructs a new AutoLocker, immediately locking the provided SemaphoreSlim
            </summary>
            <param name="semaphore">SemaphoreSlim to lock immediately</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the provided SemaphoreSlim is null</exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.AutoLocker.#ctor(System.Threading.Mutex)">
            <summary>
            Constructs a new AutoLocker, immediately locking the provided Mutex
            </summary>
            <param name="mutex">Mutex to lock immediately</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the provided Mutex is null</exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.AutoLocker.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.ByteArrayExtensions">
            <summary>
            Provides some extensions useful for byte arrays
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ByteArrayExtensions.ToMD5String(System.Byte[])">
            <summary>
            Calculates the md5sum for the provided binary data
            </summary>
            <param name="data">Binary data to hash</param>
            <returns>hex-encoded md5sum for the provided data</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ByteArrayExtensions.ToUTF8String(System.Byte[])">
            <summary>
            Provides a UTF-8 encoded string from the given binary data
            </summary>
            <param name="data">Binary data to encode as a UTF-8 string</param>
            <returns>The string representation of the binary data</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ByteArrayExtensions.ToBase64(System.Byte[])">
            <summary>
            Provides a base64 encoding of the given data. Basically a wrapper around
            System.Convert.ToBase64String
            </summary>
            <param name="data">data to encode</param>
            <returns>base64 representation</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ByteArrayExtensions.ToMemoryStream(System.Byte[])">
            <summary>
            Converts a byte array to memory stream
            - treats null like empty array
            </summary>
            <param name="bytes">input bytes</param>
            <returns>MemoryStream wrapping input bytes</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ByteArrayExtensions.ToArraySegment(System.Byte[])">
            <summary>
            </summary>
            <param name="bytes">input bytes</param>
            <returns>ArraySegment wrapping input bytes</returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.DeepEqualityTester">
            <summary>
            Provides a mechanism to test deep-equality of two objects with
            an optional list of properties to ignore by name. Deep equality
            testing bypasses reference-checking of container objects and compares
            primitive propertyt values. Use this to test whether or not two
            objects essentially contain the same data. More conveniently,
            use the following extension methods:
            - DeepEquals -> performs default deep equality testing
            - DeepSubEquals -> tests if one object matches another, for all the properties that the first has in common with the second
            - DeepIntersectionEquals -> tests deep equality only on properties which can be matched by name and type
            </summary>
        </member>
        <member name="T:Imported.PeanutButter.Utils.DeepEqualityTester.EnumComparisonStrategies">
            <summary>
            Describes available methods for comparing enum values
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.DeepEqualityTester.EnumComparisonStrategies.ByName">
            <summary>
            Compare enum values by name (default)
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.DeepEqualityTester.EnumComparisonStrategies.ByObjectEquals">
            <summary>
            Compare enum values by object equality (.Equals())
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.DeepEqualityTester.EnumComparisonStrategies.ByIntegerValue">
            <summary>
            Compare enum values by integer value
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.DeepEqualityTester.RecordErrors">
            <summary>
            Toggle whether or not to record equality errors
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.DeepEqualityTester.FailOnMissingProperties">
            <summary>
            Toggle whether or not equality testing fails when properties found
            on the first object are not found on the corresponding other object
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.DeepEqualityTester.OnlyTestIntersectingProperties">
            <summary>
            Toggle whether or not to only test properties found on both objects
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.DeepEqualityTester.Errors">
            <summary>
            Provides a list of errors for diagnosing inequality, if RecordErrors has been
            set to true
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.DeepEqualityTester.IncludeFields">
            <summary>
            Flag: include fields in deep equality testing (false by default)
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.DeepEqualityTester.OnlyCompareShape">
            <summary>
            Toggle only testing the shape of the objects provided.
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.DeepEqualityTester.VerbosePropertyMismatchErrors">
            <summary>
            Include full object dumps when storing errors about property mismatches
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.DeepEqualityTester.EnumComparisonStrategy">
            <summary>
            When comparing enum values, forget their type and only compare
            their integer values
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.DeepEqualityTester.#ctor(System.Object,System.Object,System.String[])">
            <summary>
            Constructs a new DeepEqualityTester for a source object and compare object
            with an optional params array of properties to ignore by name, all the way down
            </summary>
            <param name="objSource">Source / master object</param>
            <param name="objCompare">Object to compare with</param>
            <param name="ignorePropertiesByName">Params array of properties to ignore by name</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.DeepEqualityTester.AreDeepEqual">
            <summary>
            Calculates if the two objects provided during construction are DeepEqual
            according to the properties set. Will always re-calculate, so if one of the
            provided objects changes, this will always return the current value.
            </summary>
            <returns>True if the two objects are found to match; false otherwise.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.DeepEqualityTester.AddCustomComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Adds a custom comparer for the type T
            </summary>
            <param name="comparer"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.DeepEqualityTester.AddCustomComparer(System.Object)">
            <summary>
            Adds a custom comparer to use for the specified type.
            Custom comparers must implement IComparer&lt;T&gt; where T
            becomes the type selection to use for when the comparer
            is invoked
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="T:Imported.PeanutButter.Utils.IEnumerableWrapper">
            <summary>
            Used to describe a wrapper
            - IsValid should flag whether or not the wrapping was successful
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.IEnumerableWrapper.IsValid">
            <summary>
            Flag: communicates if the wrapping was successful. Unsuccessful wraps
            will result in empty enumerations.
            </summary>
        </member>
        <member name="T:Imported.PeanutButter.Utils.EnumerableWrapper">
            <summary>
            Wraps an object which would be an acceptable enumerable in a foreach
            (due to .NET compile-time duck-typing) into an actual IEnumerator
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.EnumerableWrapper.IsValid">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.EnumerableWrapper.#ctor(System.Object)">
            <summary>
            Construct an EnumerableWrapper around a (hopefully) enumerable object
            </summary>
            <param name="toWrap"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.EnumerableWrapper.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.EnumerableWrapper.MakeEnumerator``1">
            <summary>
            Creates the enumerator
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.EnumerableWrapper`1">
            <summary>
            Provides the typed EnumerableWrapper
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.EnumerableWrapper`1.#ctor(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.EnumeratorWrapper`1">
            <summary>
            Wraps an object which would be an acceptable enumerator in a foreach
            (due to .NET compile-time duck-typing) into an actual IEnumerator
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.EnumeratorWrapper`1.IsValid">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.EnumeratorWrapper`1.#ctor(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.EnumeratorWrapper`1.MoveNext">
            <summary>
            Implements the MoveNext functionality of IEnumerable
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.EnumeratorWrapper`1.Reset">
            <summary>
            Implements the Reset functionality of IEnumerable
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.EnumeratorWrapper`1.Current">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.EnumeratorWrapper`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.ObjectComparisons">
            <summary>
            Determines the comparison strategy for DeepEquals and friends
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.ObjectComparisons.PropertiesAndFields">
            <summary>
            Test properties and fields (default behavior for DeepEquals)
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.ObjectComparisons.PropertiesOnly">
            <summary>
            Only test properties (behavior for PropertyAssert)
            </summary>
        </member>
        <member name="T:Imported.PeanutButter.Utils.ObjectExtensions">
            <summary>
            Provides a set of convenience extensions on everything
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.DeepEquals(System.Object,System.Object,System.String[])">
            <summary>
            Runs a deep equality test between two objects, glossing over reference
            differences between class-types and comparing only primitive types. Use
            this when you'd like to essentially test whether the data in one object
            hierachy matches that of another
            </summary>
            <param name="objSource">Object which is the source of truth</param>
            <param name="objCompare">Object to compare with</param>
            <param name="ignorePropertiesByName">Params array of properties to ignore by name</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ShapeEquals(System.Object,System.Object,System.String[])">
            <summary>
            Tests if two objects have the same "shape" -- basically Deep Equality testing
            without actually testing final property values.
            </summary>
            <param name="objSource">Source / Master object</param>
            <param name="objCompare">Comparison object</param>
            <param name="ignorePropertiesByName">Ignore these properties by name</param>
            <returns>True if the "shapes" are the same, false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ShapeSubEquals(System.Object,System.Object,System.String[])">
            <summary>
            Tests if a second object has at least the "shape" of a primary one. Basically
            a DeepSubEquals without testing final property values.
            without actually testing final property values.
            </summary>
            <param name="objSource">Source / Master object</param>
            <param name="objCompare">Comparison object</param>
            <param name="ignorePropertiesByName">Ignore these properties by name</param>
            <returns>True if the comparison object "contains the shape" of the source object, false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.DeepEquals(System.Object,System.Object,Imported.PeanutButter.Utils.ObjectComparisons,System.String[])">
            <summary>
            Runs a deep equality test between two objects, glossing over reference
            differences between class-types and comparing only primitive types. Use
            this when you'd like to essentially test whether the data in one object
            hierachy matches that of another
            </summary>
            <param name="objSource">Object which is the source of truth</param>
            <param name="objCompare">Object to compare with</param>
            <param name="comparison">Method for comparison</param>
            <param name="ignorePropertiesByName">Params array of properties to ignore by name</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.DeepEquals(System.Object,System.Object,System.Action{System.String},System.String[])">
            <summary>
            Runs a deep equality test between two objects,
            ignoring reference differences wherever possible
            and logging failures with the provided action. Properties
            can be explided by name with the ignorePropertiesByName params
            </summary>
            <param name="objSource"></param>
            <param name="objCompare"></param>
            <param name="failureLogAction"></param>
            <param name="ignorePropertiesByName"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.DeepSubEquals(System.Object,System.Object,System.String[])">
            <summary>
            Runs a deep equality test between two objects, using the properties on objSource (and children) as
            the set of properties to match on
            </summary>
            <param name="objSource">Source object to perform comparison against</param>
            <param name="objCompare">Comparison object to compare</param>
            <param name="ignorePropertiesByName">Optional params array of properties to ignore by name</param>
            <returns>True if relevant properties are found and match; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.DeepIntersectionEquals(System.Object,System.Object,System.String[])">
            <summary>
            Runs a deep equality test between two objects, using the properties common to both sides
            of the comparison to match on.
            </summary>
            <param name="objSource">Source object to perform comparison against</param>
            <param name="objCompare">Comparison object to compare</param>
            <param name="ignorePropertiesByName">Optional params array of properties to ignore by name</param>
            <returns>True if relevant properties are found and match; false otherwise. If no common properties are found, returns false; caveat: performing this comparison on two vanilla Object() instances will return true.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ContainsAtLeastOneDeepEqualTo``2(System.Collections.Generic.IEnumerable{``0},``1,System.String[])">
            <summary>
            Searches a collection for one or more objects which DeepEquals the provided reference item
            </summary>
            <param name="collection">Collection of objects to search</param>
            <param name="item">Item to find a match for</param>
            <param name="ignoreProperties">Optional params array of properties to ignore by name</param>
            <typeparam name="T1">Item type of the collection</typeparam>
            <typeparam name="T2">Type of the comparison item (can be the same as or different from T1)</typeparam>
            <returns>True if one or more matching objects were found; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ContainsOneDeepEqualTo``2(System.Collections.Generic.IEnumerable{``0},``1,System.String[])">
            <summary>
            Searches a collection for a single object which DeepEquals the provided reference item
            </summary>
            <param name="collection">Collection of objects to search</param>
            <param name="item">Item to find a match for</param>
            <param name="ignoreProperties">Optional params array of properties to ignore by name</param>
            <typeparam name="T1">Item type of the collection</typeparam>
            <typeparam name="T2">Type of the comparison item (can be the same as or different from T1)</typeparam>
            <returns>True if one or more matching objects were found; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ContainsOneIntersectionEqualTo``2(System.Collections.Generic.IEnumerable{``0},``1,System.String[])">
            <summary>
            Searches a collection for an object which IntersectionEquals the provided reference item
            </summary>
            <param name="collection">Collection of objects to search</param>
            <param name="item">Item to find a match for</param>
            <param name="ignoreProperties">Optional params array of properties to ignore by name</param>
            <typeparam name="T1">Item type of the collection</typeparam>
            <typeparam name="T2">Type of the comparison item (can be the same as or different from T1)</typeparam>
            <returns>True if one or more matching objects were found; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ContainsOnlyOneDeepEqualTo``2(System.Collections.Generic.IEnumerable{``0},``1,System.String[])">
            <summary>
            Searches a collection for an object which DeepEquals the provided reference item
            </summary>
            <param name="collection">Collection of objects to search</param>
            <param name="item">Item to find a match for</param>
            <param name="ignoreProperties">Optional params array of properties to ignore by name</param>
            <typeparam name="T1">Item type of the collection</typeparam>
            <typeparam name="T2">Type of the comparison item (can be the same as or different from T1)</typeparam>
            <returns>True if exactly one matching object was found; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ContainsOnlyOneIntersectionEqualTo``2(System.Collections.Generic.IEnumerable{``0},``1,System.String[])">
            <summary>
            Searches a collection for an object which IntersectionEquals the provided reference item
            </summary>
            <param name="collection">Collection of objects to search</param>
            <param name="item">Item to find a match for</param>
            <param name="ignoreProperties">Optional params array of properties to ignore by name</param>
            <typeparam name="T1">Item type of the collection</typeparam>
            <typeparam name="T2">Type of the comparison item (can be the same as or different from T1)</typeparam>
            <returns>True if exactly one matching object was found; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ContainsOnlyOneMatching``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,``1,System.Boolean})">
            <summary>
            Searches a collection for an object which matches the provided reference item, according
            to the provided matcher Func
            </summary>
            <param name="collection">Collection of objects to search</param>
            <param name="item">Item to find a match for</param>
            <param name="comparer">Func to use to perform comparison</param>
            <typeparam name="T1">Item type of the collection</typeparam>
            <typeparam name="T2">Type of the comparison item (can be the same as or different from T1)</typeparam>
            <returns>True if exactly one matching object was found; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.CopyPropertiesTo(System.Object,System.Object)">
            <summary>
            Copies all public primitive property values of intersecting properties from the source object
            to the target object, ala poor-man's AutoMapper
            </summary>
            <param name="src">Source object</param>
            <param name="dst">Target object</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.CopyPropertiesTo(System.Object,System.Object,System.String[])">
            <summary>
            Copies all public primitive property values of intersecting properties from the source object
            to the target object, ala poor-man's AutoMapper
            </summary>
            <param name="src">Source object</param>
            <param name="dst">Target object</param>
            <param name="ignoreProperties">Optional list of properties to ignore by name</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.CopyPropertiesTo(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>
            Copies all public primitive property values of intersecting properties from the source object
            to the target object, ala poor-man's AutoMapper
            </summary>
            <param name="src">Source object</param>
            <param name="dst">Target object</param>
            <param name="deep">Flag as to whether or not the process should copy deep (ie, traverse into child objects)</param>
            <param name="ignoreProperties"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.DeepClone``1(``0)">
            <summary>
            Creates a deep clone of the provided item, as far as possible
            Works on properties which are:
             * simple values,
             * any complex, non-generic value with a parameterless constructor
             * Collections which are arrays, generic IEnumerable or generic List,
                 conforming to the rules above
            </summary>
            <param name="item">Item to clone</param>
            <typeparam name="T">Type of the item to clone</typeparam>
            <returns>a new copy of the original item</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.Get``1(System.Object,System.String)">
            <summary>
            Gets the value of a property on an object, specified by the property path, of the given Type
            </summary>
            <param name="src">Object to search for the required property</param>
            <param name="propertyPath">Path to the property: may be a property name or a dotted path down an object heirachy, eg: Company.Name</param>
            <typeparam name="T">Expected type of the property value</typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.GetOrDefault``1(System.Object,System.String)">
            <summary>
            Gets the value of a property on an object, specified by the property path, of the given Type
            or returns a default value when that property cannot be found by path and/or type
            </summary>
            <param name="src"></param>
            <param name="propertyPath"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.GetOrDefault``1(System.Object,System.String,``0)">
            <summary>
            Gets the value of a property on an object, specified by the property path, of the given Type
            or returns a default value when that property cannot be found by path and/or type
            </summary>
            <param name="src"></param>
            <param name="propertyPath"></param>
            <param name="defaultValue"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.AsArray``1(``0)">
            <summary>
            Fluency extension to wrap a single item in an array, eg:
            new SomeBusinessObject().AsArray().Union(SomeOtherCollection);
            </summary>
            <param name="input">The item to wrap</param>
            <typeparam name="T">The type of the object</typeparam>
            <returns>A single-element array containing the input object</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.GetPropertyValue(System.Object,System.String)">
            <summary>
            Gets a property value by name from an object
            </summary>
            <param name="src">Source object</param>
            <param name="propertyPath">Name of the property to search for</param>
            <returns>Value of the property, cast/boxed to object</returns>
            <exception cref="T:Imported.PeanutButter.Utils.MemberNotFoundException">Thrown when the property is not found by name</exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.InvokeMethodWithResult(System.Object,System.String,System.Object[])">
            <summary>
            Invokes a method on an object, if available; otherwise 'splodes
            </summary>
            <param name="src">Object to invoke the method on</param>
            <param name="methodName">Method to invoke, by name</param>
            <param name="args">Any parameters to give to the method</param>
            <returns>return value of the method</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Attempts to set a property value on an object by property path
            </summary>
            <param name="src">Source object to set property on</param>
            <param name="propertyPath">Path into the property: could be an immediate property name or something like "Company.Name"</param>
            <param name="newValue">New value to attempt to set the property to</param>
            <exception cref="T:Imported.PeanutButter.Utils.MemberNotFoundException">Thrown when the property cannot be found</exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.Set``1(System.Object,System.String,``0)">
            <summary>
            Attempts to set a property value on an object by property path
            </summary>
            <param name="src"></param>
            <param name="propertyPath"></param>
            <param name="newValue"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.TrySet``1(System.Object,System.String,``0)">
            <summary>
            attempts to set a property value on an object by path and value
            - will not throw on error, but will return false instead
            </summary>
            <param name="src"></param>
            <param name="propertyPath"></param>
            <param name="newValue"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.GetPropertyValue``1(System.Object,System.String)">
            <summary>
            Gets an immediate property value, cast to the specified type
            </summary>
            <param name="src">Source object</param>
            <param name="propertyPath">Immediate property name</param>
            <typeparam name="T">Required type</typeparam>
            <returns>Value of the property, if it can be found and cast. Will throw otherwise.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.IsAssignableTo``1(System.Type)">
            <summary>
            Tests if a type is assignable to another type (inverse of IsAssignableFrom)
            </summary>
            <param name="type">Type to operate on</param>
            <typeparam name="T">Type to check assignment possibility against</typeparam>
            <returns>True if objects of type {type} can be assigned to objects of type T</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.TruncateTo(System.Decimal,System.Int32)">
            <summary>
            Truncates a decimal value to a required number of places
            </summary>
            <param name="value">Source decimal value</param>
            <param name="places">Number of decimal places required</param>
            <returns>A new decimal value which is the original value truncated to the required places</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.TruncateTo(System.Double,System.Int32)">
            <summary>
            Truncates a decimal value to a required number of places
            </summary>
            <param name="value">Source decimal value</param>
            <param name="places">Number of decimal places required</param>
            <returns>A new decimal value which is the original value truncated to the required places</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ToFixed(System.Decimal,System.Int32)">
            <summary>
            Provides a similar api to Javascript's
            .toFixed(), except returning a useful decimal!
            Note: this is different from .TruncateTo since that will
            truncate the value, whereas this will round
            </summary>
            <param name="value">Source decimal value</param>
            <param name="places">Number of decimal places required</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.ToFixed(System.Double,System.Int32)">
            <summary>
            Provides a similar api to Javascript's
            .toFixed(), except returning a useful double!
            Note: this is different from .TruncateTo since that will
            truncate the value, whereas this will round
            </summary>
            <param name="value">Source double value</param>
            <param name="places">Number of double places required</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.AsEnumerable``1(System.Object)">
            <summary>
            Attempts to convert any object to an IEnumerable&lt;T&gt;
            - existing IEnumerables will "just work"
            - where possible, types are cast or converted
              - eg an array of strings which are numbers will be converted to ints if required
            - also deals with objects which don't implement IEnumerable, but are enumerable
              in a foreach as per C#/.NET compile-time duck-typing, like Regex's MatchCollection
            </summary>
            <param name="src">Object to operate on</param>
            <typeparam name="T">Desired collection element type</typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.TryChangeType``1(System.Object,``0@)">
            <summary>
            Analogous to TryParse methods, this will attempt to convert a value to
            the type T, returning true if it can, and populating the output parameter
            </summary>
            <param name="input">Value to work on</param>
            <param name="output">Output parameter to collect result</param>
            <typeparam name="T">Desired type</typeparam>
            <returns>True when can ChangeType, false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.TryChangeType(System.Object,System.Type,System.Object@)">
            <summary>
            Analogous to TryParse methods, this will attempt to convert a value to
            the type requiredType, returning true if it can, and populating the output parameter
            </summary>
            <param name="input">Value to work on</param>
            <param name="requiredType">The required type</param>
            <param name="output">Output parameter to collect result</param>
            <returns>True when can ChangeType, false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.IsInstanceOf``1(System.Object)">
            <summary>
            Tests if the given object is an instance of the type T
            - returns false if obj is null
            - returns true if T is the exact type of obj
            - returns true if T is a base type of obj
            - returns true if T is an interface implemented by obj
            - returns false otherwise
            </summary>
            <param name="obj"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.IsInstanceOf(System.Object,System.Type)">
            <summary>
            Tests if the given object is an instance of the provided type
            - returns false if obj is null
            - returns true if the type is the exact type of obj
            - returns true if the type is a base type of obj
            - returns true if the type is an interface implemented by obj
            - returns false otherwise
            </summary>
            <param name="obj"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ObjectExtensions.IsRuntimeType(System.Object)">
            <summary>
            Determines whether or not an arbitrary object is a RuntimeType
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.ExtensionsForIEnumerables">
            <summary>
            Useful extensions for IEnumerable&lt;T&gt; collections
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The missing ForEach method
            </summary>
            <param name="collection">Subject collection to operate over</param>
            <param name="toRun">Action to run on each member of the collection</param>
            <typeparam name="T">Item type of the collection</typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The missing ForEach method - synchronous variant which also provides the current item index
            </summary>
            <param name="collection">Subject collection to operate over</param>
            <param name="toRunWithIndex">Action to run on each member of the collection</param>
            <typeparam name="T">Item type of the collection</typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FindOrAdd``1(System.Collections.Generic.ICollection{``0},``0)">
            <summary>
            Find or add an item to a collection
            - item equality is determined by T.Equals
            </summary>
            <param name="collection"></param>
            <param name="seek"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FindOrAdd``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
            <summary>
            Find or add an item to a collection
            - item equality is determined by the provided matcher
            - new items are generated with `new T()`
            </summary>
            <param name="collection"></param>
            <param name="matcher"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FindOrAdd``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean},System.Func{``0})">
            <summary>
            Find or add an item to a collection
            - item equality is determined by the provided matcher
            - new items are generated with the provided matcher
            </summary>
            <param name="collection"></param>
            <param name="matcher"></param>
            <param name="generator"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the collection, matcher or generator are null
            </exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.IsSameAs``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Calculates if two collections hold the same items, irrespective of order
            </summary>
            <param name="collection">Source collection</param>
            <param name="otherCollection">Collection to compare with</param>
            <typeparam name="T">Item type of the collections</typeparam>
            <returns>True if all values in the source collection are found in the target collection</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.JoinWith``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Fluent alternative to string.Join()
            </summary>
            <param name="collection">Source collection to operate on</param>
            <param name="joinWith">String to join items with</param>
            <typeparam name="T">Underlying type of the collection</typeparam>
            <returns>
            string representing items of the collection joined with the joinWith parameter.
            Where a collection of non-strings is provided, the objects' ToString() methods
            are used to get a string representation.
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method, essentially opposite to Any(), except
            that it also handles null collections
            </summary>
            <param name="collection">Source collection to operate on</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>True if the collection is null or has no items; false otherwise.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.EmptyIfNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method to mitigate null checking and errors when
            a null collection can be treated as if it were empty, eg:
            someCollection.EmptyIfNull().ForEach(DoSomething);
            </summary>
            <param name="collection">Source collection to operate over</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>An empty collection if the source is null; otherwise the source.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.And``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Convenience method to create a new array with the provided element(s) appended
            </summary>
            <param name="source">Source array to start with</param>
            <param name="values"></param>
            <typeparam name="T">Item type of the array</typeparam>
            <returns>A new array which is the source with the new items appended</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.And``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method to create a new array with the provided element(s) appended
            </summary>
            <param name="source">Source array to start with</param>
            <param name="values"></param>
            <typeparam name="T">Item type of the array</typeparam>
            <returns>A new array which is the source with the new items appended</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.And``1(``0[],``0[])">
            <summary>
            Convenience method to create a new array with the provided element(s) appended
            </summary>
            <param name="source">Source array to start with</param>
            <param name="values"></param>
            <typeparam name="T">Item type of the array</typeparam>
            <returns>A new array which is the source with the new items appended</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.And``1(``0[],System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method to create a new array with the provided element(s) appended
            </summary>
            <param name="source">Source array to start with</param>
            <param name="values"></param>
            <typeparam name="T">Item type of the array</typeparam>
            <returns>A new array which is the source with the new items appended</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.And``1(System.Collections.Generic.List{``0},``0[])">
            <summary>
            Convenience method to add one one or more values to a list
            </summary>
            <param name="source"></param>
            <param name="values"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.And``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>
            Convenience method to add more values to a list
            </summary>
            <param name="source"></param>
            <param name="values"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ButNot``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Convenience / fluent method to provide an array without the provided item(s)
            </summary>
            <param name="source">Source collection</param>
            <param name="toRemove">items which should not appear in the result array</param>
            <typeparam name="T">Item type of the array</typeparam>
            <returns>A new array of T with the specified items not present</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Convenience wrapper around SelectMany; essentially flattens a nested collection
            of collection(s) of some item. Exactly equivalent to:
            collection.SelectMany(o => o);
            </summary>
            <param name="collection">Source collection to operate on</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>A new, flat collection</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.SelectNonNull``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Convenience method to get the results of a selection where the results are non-null
            -> this variant works on Nullable types
            </summary>
            <param name="collection">Source collection to operate over</param>
            <param name="grabber">Function to grab the data you're interested in off of each source item</param>
            <typeparam name="TCollection">Item type of the source collection</typeparam>
            <typeparam name="TResult">Item type of the result collection</typeparam>
            <returns>
            A new collection which is the result of a Select with the provided grabber
            where the Select results are non-null
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.SelectNonNull``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Convenience method to get the results of a selection where the results are non-null
            -> this variant works on types which can natively hold the value null
            </summary>
            <param name="collection">Source collection to operate over</param>
            <param name="grabber">Function to grab the data you're interested in off of each source item</param>
            <typeparam name="TCollection">Item type of the source collection</typeparam>
            <typeparam name="TResult">Item type of the result collection</typeparam>
            <returns>
            A new collection which is the result of a Select with the provided grabber
            where the Select results are non-null
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.AsText``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Convenience method to produce a block of text from a collection of items
            -> optionally, delimit with a string of your choice instead of a newline
            -> essentially a wrapper around JoinWith()
            </summary>
            <param name="input">Source input lines</param>
            <param name="delimiter">Optional delimiter (default is Environment.NewLine)</param>
            <typeparam name="T">Item type of collection</typeparam>
            <returns>String representation of the the items</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.HasUnique``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Convenience method to test if a collection has a single item matching the
            provided matcher function
            </summary>
            <param name="input">Source collection</param>
            <param name="matcher">Function to run over each item to test if it passes</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>
            True if only one item in the collection got a true value from the matcher
            function; false if zero or more than one items were matched.
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.TimesDo(System.Int32,System.Action)">
            <summary>
            Fluency method to run an action a certain number of times, eg:
            10.TimesDo(() => Console.WriteLine("Hello World"));
            </summary>
            <param name="howMany">Number of times to run the provided action</param>
            <param name="toRun">Action to run</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.TimesDo(System.Int32,System.Action{System.Int32})">
            <summary>
            Fluency method to run an action a certain number of times. This
            variant runs on an action given the current index at each run, eg:
            10.TimesDo(i => Console.WriteLine($"This action has run {i} times"));
            </summary>
            <param name="howMany">Number of times to run the provided action</param>
            <param name="toRun">Action to run</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Second``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method to get the second item from a collection
            </summary>
            <param name="src">Source collection</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>The second item, when available. Will throw if there is no item available.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Third``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Convenience method to get the third item from a collection
            </summary>
            <param name="src">Source collection</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>The third item, when available. Will throw if there is no item available.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FirstAfter``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Convenience method to get the first item after skipping N items from a collection
            -> equivalent to collection.Skip(N).First();
            -> collection.FirstAfter(2) returns the 3rd element
            </summary>
            <param name="src">Source collection</param>
            <param name="toSkip">How many items to skip</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>The third item, when available. Will throw if there is no item available.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FirstOrDefaultAfter``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Convenience method to get the first item after skipping N items from a collection
            -> equivalent to collection.Skip(N).First();
            -> collection.FirstAfter(2) returns the 3rd element
            -> this variant returns the default value for T if the N is out of bounds
            </summary>
            <param name="src">Source collection</param>
            <param name="toSkip">How many items to skip</param>
            <typeparam name="T">Item type of the collection</typeparam>
            <returns>The third item, when available. Will return the default value for T otherwise.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FindDuplicates``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Find duplicates within a collection according to a provided discriminator
            </summary>
            <param name="src">Collection to operate on</param>
            <typeparam name="TItem">Type of items in the collection</typeparam>
            <returns>Collection of duplicate items</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.FindDuplicates``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Find duplicates within a collection according to a provided discriminator
            </summary>
            <param name="src">Collection to operate on</param>
            <param name="discriminator">Function to determine uniqueness of each item: should
            return whatever identifies a particular item uniquely</param>
            <typeparam name="TItem">Type of items in the collection</typeparam>
            <typeparam name="TKey">Type of key used to discriminate items</typeparam>
            <returns>Collection of DuplicateResult items which contain duplicates, according to the provided discriminator</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.None``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Inverse of All() LINQ method: test should return false for all elements
            </summary>
            <param name="collection"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.None``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Inverse of All() LINQ method: test should return false for all elements
            </summary>
            <param name="collection"></param>
            <param name="test"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.DuplicateResult`2">
            <summary>
            DTO for conveying results from the more complex FindDuplicates
            variant which includes a key discriminator
            </summary>
            <typeparam name="TKey">Type of the key that duplication was determined by</typeparam>
            <typeparam name="TItem">Type of the duplicated item(s)</typeparam>
        </member>
        <member name="P:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.DuplicateResult`2.Key">
            <summary>
            Key of duplication
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.DuplicateResult`2.Items">
            <summary>
            Duplicated items matching this key
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.DuplicateResult`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Constructs a read-only dto
            </summary>
            <param name="key">Key value</param>
            <param name="items">Duplicated items</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ImplicitCast``1(System.Collections.IEnumerable)">
            <summary>
            Performs implicit casting on a collection
            -> just like .Cast&lt;T&gt;, this will explode if the
                cast cannot succeed. C'est la vie
            </summary>
            <param name="collection"></param>
            <typeparam name="TOther"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.StrictZip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Similar to LINQ's Zip extension method, this will zip
            two enumerables together using yield
            - however it will throw an exception if one enumerable
            runs out before the other
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <typeparam name="TLeft"></typeparam>
            <typeparam name="TRight"></typeparam>
            <returns>A new collection of Tuple&lt;TLeft, TRight&gt;</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.StrictZip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Similar to LINQ's Zip extension method, this will zip
            two enumerables together using yield
            - however it will throw an exception if one enumerable
            runs out before the other
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <param name="generator">generator function to produce each item of TResult</param>
            <typeparam name="TLeft"></typeparam>
            <typeparam name="TRight"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns>A new collection of TResult, as determined by your generator function</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Matches``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Performs full-collection matching on two collections of the same type,
            assuming that .Equals() is a valid comparator between two objects of type T
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <typeparam name="T"></typeparam>
            <returns>
            true if collections are of the same size and each item, in order,
            from the left item, matches the right one
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Matches``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Performs matching on collections of the same type
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <param name="comparer">function used to compare two values</param>
            <typeparam name="T"></typeparam>
            <returns>
            true if collections are of the same size and each item, in order,
            from the left item, matches the right one
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.CrossMatches``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Performs cross-type matching on collections
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <param name="comparer">function to compare items</param>
            <typeparam name="TLeft"></typeparam>
            <typeparam name="TRight"></typeparam>
            <returns>
            true if collections are of the same size and each item, in order,
            from the left item, matches the right one
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.Trim(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns the original collection of strings trimmed
            - will handle null input as if it were an empty collection
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.TrimStart(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns the original collection of strings trimmed at the start
            - will handle null input as if it were an empty collection
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.TrimEnd(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns the original collection of strings trimmed at the start
            - will handle null input as if it were an empty collection
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.PadLeft``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a copy of the input strings where
            all are padded to the left with spaces to fit
            to the longest item in the collection
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.PadLeft``1(System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>
            Returns a copy of the input strings where
            all are padded to the left with the `padWith`
            char to fit to the longest item in the collection
            </summary>
            <param name="source"></param>
            <param name="padWith"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.PadLeft``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns a copy of the input strings where
            all are padded to the left to the provided
            required length with spaces
            </summary>
            <param name="source"></param>
            <param name="requiredLength"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.PadLeft``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Char)">
            <summary>
            Returns a copy of the input strings where
            all are padded to the left to the provided
            required length with the provided padWith
            character
            </summary>
            <param name="source"></param>
            <param name="requiredLength"></param>
            <param name="padWith"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.PadRight``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a copy of the input strings where
            all are padded to the right with spaces to fit
            to the longest item in the collection
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.PadRight``1(System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>
            Returns a copy of the input strings where
            all are padded to the right with the `padWith`
            char to fit to the longest item in the collection
            </summary>
            <param name="source"></param>
            <param name="padWith"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.PadRight``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns a copy of the input strings where
            all are padded to the right with spaces
            char to fit to the requiredLength
            </summary>
            <param name="source"></param>
            <param name="requiredLength"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.PadRight``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Char)">
            <summary>
            Returns a copy of the input strings where
            all are padded to the right with the `padWith`
            char to fit to the requiredLength
            </summary>
            <param name="source"></param>
            <param name="requiredLength"></param>
            <param name="padWith"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.IsEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Compares two collections and returns true if they have exactly the
            same values in the same order
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.IsEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Compares two collections and returns true if they have
            exactly the same values in any order
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.ExtensionsForIEnumerables.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces an hashset from a collection
            -> shorthand for new HashSet&lt;T&gt;(collection)
            </summary>
            <param name="collection"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.MetadataExtensions">
            <summary>
            Provides extension methods to set and retrieve metadata on any object.
            Under the hood, these methods use a ConditionalWeakTable to store your
            metadata, so the metadata is garbage-collected when your managed objects
            are garbage-collected.
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.SetMetadata(System.Object,System.String,System.Object)">
            <summary>
            Sets an arbitrary piece of metadata on a managed object. This metadata
            has the same lifetime as your object, meaning it will be garbage-collected
            when your object is garbage-collected, assuming nothing else is referencing
            it.
            </summary>
            <param name="parent">Object to store metadata against</param>
            <param name="key">Name of the metadata item to set</param>
            <param name="value">Value to store</param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.GetMetadata``1(System.Object,System.String)">
            <summary>
            Attempts to retrieve a piece of metadata for an object. When the
            metadata key for the object is unknown, returns the default value
            for the type requested, eg 0 for ints, null for strings and objects.
            Note that if metadata exists for the requested key but not for the
            type requested, a type-casting exception will be thrown.
            </summary>
            <param name="parent">Parent object to query against</param>
            <param name="key">Key to query for</param>
            <typeparam name="T">Type of data</typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.GetMetadata``1(System.Object,System.String,``0)">
            <summary>
            Attempts to retrieve a piece of metadata for an object. When the
            metadata key for the object is unknown, returns the default value
            for the type requested, eg 0 for ints, null for strings and objects.
            Note that if metadata exists for the requested key but not for the
            type requested, a type-casting exception will be thrown.
            This overload allows specifying a default value.
            </summary>
            <param name="parent">Parent object to query against</param>
            <param name="key">Key to query for</param>
            <param name="defaultValue"></param>
            <typeparam name="T">Type of data</typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.HasMetadata``1(System.Object,System.String)">
            <summary>
            Tests if a parent object has a piece of metadata with the provided type.
            </summary>
            <param name="parent">Parent object to search against</param>
            <param name="key">Key to search for</param>
            <typeparam name="T">Expected type of metadata</typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.HasMetadata(System.Object)">
            <summary>
            Tests if an object has any metadata stored against it at all
            - will always return false for a null object
            </summary>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.HasMetadata(System.Object,System.String)">
            <summary>
            Tests if an object has metadata with the provided key
            - will always return false for a null object
            </summary>
            <param name="parent"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.DeleteMetadata(System.Object)">
            <summary>
            Deletes all metadata associated with the object, if any
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.DeleteMetadata(System.Object,System.String)">
            <summary>
            Deletes the metadata identified by the key for this
            object, if found
            </summary>
            <param name="parent"></param>
            <param name="key"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.TryGetMetadata``1(System.Object,System.String,``0@)">
            <summary>
            Try get the named metadata for the provided type
            </summary>
            <param name="parent"></param>
            <param name="key"></param>
            <param name="result"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MetadataExtensions.CopyAllMetadataTo(System.Object,System.Object)">
            <summary>
            Clones all the metadata from parent to target
            - will overwrite target data with the same key!
            </summary>
            <param name="parent"></param>
            <param name="target"></param>
        </member>
        <member name="T:Imported.PeanutButter.Utils.MemberNotFoundException">
            <summary>
            Exception thrown when a property cannot be found by name
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.MemberNotFoundException.#ctor(System.Type,System.String)">
            <summary>
            Constructs a new MemberNotFoundException
            </summary>
            <param name="type">The Type being searched for the property</param>
            <param name="propertyName">The name of the property which was not found</param>
        </member>
        <member name="T:Imported.PeanutButter.Utils.PropertyOrFieldTypes">
            <summary>
            Differentiates between PropertyOrField storage for properties or fields
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.PropertyOrFieldTypes.Property">
            <summary>
            This member is a Property
            </summary>
        </member>
        <member name="F:Imported.PeanutButter.Utils.PropertyOrFieldTypes.Field">
            <summary>
            This member is a Field
            </summary>
        </member>
        <member name="T:Imported.PeanutButter.Utils.IPropertyOrField">
            <summary>
            Represents a property or a field on an object
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.IPropertyOrField.Name">
            <summary>
            Name of the property or field
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.IPropertyOrField.Type">
            <summary>
            Type of the property or field
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.IPropertyOrField.CanWrite">
            <summary>
            Write access to property or field
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.IPropertyOrField.CanRead">
            <summary>
            Read access to property or field
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.IPropertyOrField.DeclaringType">
            <summary>
            The type on which this property or field is declared
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.IPropertyOrField.HostingType">
            <summary>
            The type from which this property or field is read
            - this may not be the DeclaringType as the property
            or field may be inherited
            - this must be explicitly provided by callers
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.IPropertyOrField.AncestralDistance">
            <summary>
            Returns the ancestral distance between the DeclaringType
            and the HostingType (0 if they are the same type)
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.IPropertyOrField.GetValue(System.Object)">
            <summary>
            Gets the value of the property or field for the provided host
            </summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.IPropertyOrField.TryGetValue(System.Object,System.Object@,System.Exception@)">
            <summary>
            Attempts to get the value of the property
            - if the getter throws, returns false and the output exception is set
            - if the getter succeeds, returns true and the output value is set
            </summary>
            <param name="host"></param>
            <param name="value"></param>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.IPropertyOrField.SetValue(System.Object,System.Object)">
            <summary>
            Sets the value of the property or field on the provided host
            </summary>
            <param name="host"></param>
            <param name="value"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.IPropertyOrField.SetValue``1(``0@,System.Object)">
            <summary>
            Sets the value for the field or property
            as found on the provided host
            </summary>
            <param name="host"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Imported.PeanutButter.Utils.PropertyOrField">
            <summary>
            Provides a single storage / representation
            for a Property or a Field
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.Create(System.Reflection.PropertyInfo)">
            <summary>
            Creates a PropertyOrField container for a provided PropertyInfo
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.Create(System.Reflection.FieldInfo)">
            <summary>
            Creates a PropertyOrField container for a provided FieldInfo
            </summary>
            <param name="fieldInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.Find(System.Type,System.String)">
            <summary>
            Attempts to find a property or field with the given name on
            a type - will scan public, private, static and instance properties
            and fields. It's up to the caller to know what do to with that (:
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <exception cref="T:System.ArgumentException">thrown when the property or field is not found</exception>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.TryFind(System.Type,System.String)">
            <summary>
            Attempts to find a property or field with the given name on
            a type - will scan public, private, static and instance properties
            and fields. It's up to the caller to know what do to with that (:
            </summary>
            <param name="type"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.Name">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.Type">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.CanRead">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.MemberType">
            <summary>
            Is this a Property or a Field?
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.DeclaringType">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.HostingType">
            <inheritdoc />
        </member>
        <member name="P:Imported.PeanutButter.Utils.PropertyOrField.AncestralDistance">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Constructs the PropertyOrField around a property
            </summary>
            <param name="prop"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.#ctor(System.Reflection.PropertyInfo,System.Type)">
            <summary>
            Constructs the PropertyOrField around a property, relative
            to an hosting type (ie, without assuming that the DeclaringType
            is the hosting type for the property)
            </summary>
            <param name="prop"></param>
            <param name="hostingType"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.op_Implicit(System.Reflection.PropertyInfo)~Imported.PeanutButter.Utils.PropertyOrField">
            <summary>
            Implicitly converts a PropertyInfo object to a PropertyOrField
            </summary>
            <param name="prop"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.op_Implicit(System.Reflection.FieldInfo)~Imported.PeanutButter.Utils.PropertyOrField">
            <summary>
            Implicitly converts a FieldInfo object to a FieldOrField
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.#ctor(System.Reflection.FieldInfo)">
            <summary>
            Constructs the PropertyOrField around a field
            </summary>
            <param name="field"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.#ctor(System.Reflection.FieldInfo,System.Type)">
            <summary>
            Constructs the PropertyOrField around a field
            </summary>
            <param name="field"></param>
            <param name="hostingType"></param>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.GetValue(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.TryGetValue(System.Object,System.Object@,System.Exception@)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.SetValue(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Imported.PeanutButter.Utils.PropertyOrField.SetValue``1(``0@,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.PyLike">
            <summary>
            Provides a Python-like Range method
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PyLike.Range(System.Int32)">
            <summary>
            Produces a sequence of consecutive ints from zero to (stop - 1)
            </summary>
            <param name="stop">upper bound of sequence, not included in result</param>
            <returns>Sequence of ints</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PyLike.Range(System.Int32,System.Int32)">
            <summary>
            Produces a sequence of consecutive ints from start to (stop - 1)
            </summary>
            <param name="start"></param>
            <param name="stop"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PyLike.Range(System.Int32,System.Int32,System.Int32)">
            <summary>
            produces a sequence of ints from start to stop (not inclusive), stepping by step
            </summary>
            <param name="start">first item to expect in sequence</param>
            <param name="stop">go no higher, young padawan!</param>
            <param name="step">step up by this amount each time</param>
            <returns>Sequence of ints</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PyLike.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            "Zips" two collections together so you can enumerate over them. The
              length of the enumeration is determined by the shortest collection
            </summary>
            <param name="left">left collection</param>
            <param name="right">right collection</param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <returns>Enumeration over the collections (Tuple of T1, T2)</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.PyLike.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            "Zips" three collections together so you can enumerate over them. The
              length of the enumeration is determined by the shortest collection
            </summary>
            <param name="left">left collection</param>
            <param name="middle">right collection</param>
            <param name="right">right collection</param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <returns>Enumeration over the collections (Tuple of T1, T2, T3)</returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.StringExtensions">
            <summary>
            Provides utility extensions for strings
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.RegexReplace(System.String,System.String,System.String)">
            <summary>
            Replaces patterns matched by the given regex pattern with the given replaceWith string
            </summary>
            <param name="input">Starting string</param>
            <param name="pattern">Regex pattern to search for</param>
            <param name="replaceWith">String to replace occurrences with</param>
            <returns>New string with matches replaces</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.RegexReplaceAll(System.String,System.String,System.String[])">
            <summary>
            Replace all matching regular expression strings in input with the given string
            </summary>
            <param name="input"></param>
            <param name="replaceWith"></param>
            <param name="patterns"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.RegexReplaceAll(System.String,System.String,System.Text.RegularExpressions.Regex[])">
            <summary>
            Replace all matching Regex patterns in input with the given string
            </summary>
            <param name="input"></param>
            <param name="replaceWith"></param>
            <param name="patterns"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Or(System.String,System.String)">
            <summary>
            Convenience extension to return another string if the input is null or empty
            </summary>
            <param name="input">String to test</param>
            <param name="alternative">String to return if the input was null or empty</param>
            <returns>The original string when it is not null or empty; the alternative when the original is null or empty</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsBoolean(System.String)">
            <summary>
            Attempts conversion from a string value to a boolean value matching the following (case-insensitive) to True:
            - "yes"
            - "y"
            - "1"
            - "true"
            All other string values are considered to be false
            </summary>
            <param name="input">String to attempt to convert</param>
            <returns>True for truthy values, False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ContainsOneOf(System.String,System.String[])">
            <summary>
            Searches a master string for occurrences of any of the given strings,
            case-insensitive
            </summary>
            <param name="haystack">String to search</param>
            <param name="needles">Strings to search for</param>
            <returns>True if any of the needles are found in the haystack; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.EqualsOneOf(System.String,System.String[])">
            <summary>
            Much like ContainsOneOf, but performs a case-insensitive exact match
            for the needles against the haystack
            </summary>
            <param name="haystack"></param>
            <param name="needles"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ContainsAllOf(System.String,System.String[])">
            <summary>
            Searches a master string for occurrences of any of the given strings
            </summary>
            <param name="haystack">String to search</param>
            <param name="needles">Strings to search for</param>
            <returns>True if all of the needles are found in the haystack; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.StartsWithOneOf(System.String,System.String[])">
            <summary>
            Tests if a string starts with one of the provided search strings
            </summary>
            <param name="src">String to test</param>
            <param name="search">Strings to look for at the start of {src}</param>
            <returns>True if {src} starts with any one of provided search strings; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsBytes(System.String)">
            <summary>
            Calls AsBytes extension method with the UTF8 encoding
            </summary>
            <param name="src">String to operate on</param>
            <returns>Byte array representing string, from UTF8 encoding</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsBytes(System.String,System.Text.Encoding)">
            <summary>
            Convenience function to convert a string to a byte array
            </summary>
            <param name="src">String to convert</param>
            <param name="encoding">Encoding to use</param>
            <returns>Byte array of the {src} string when decoded as UTF-8</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsStream(System.String)">
            <summary>
            Converts a string to a Stream of bytes, assuming utf-8 encoding
            </summary>
            <param name="src">String to convert</param>
            <returns>Stream or null if src is null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToLower(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Lowercases a string collection with Invariant culture. Tolerates nulls.
            </summary>
            <param name="src">Collection to lower-case</param>
            <returns>Input, lower-cased</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToLower(System.Collections.Generic.IEnumerable{System.String},System.Globalization.CultureInfo)">
            <summary>
            Lowercases a string collection with Invariant culture. Tolerates nulls.
            </summary>
            <param name="src">Collection to lower-case</param>
            <param name="cultureInfo">Culture to use in the operation</param>
            <returns>Input, lower-cased</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToUpper(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Uppercases a string collection with Invariant culture. Tolerates nulls.
            </summary>
            <param name="src">Collection to lower-case</param>
            <returns>Input, lower-cased</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToUpper(System.Collections.Generic.IEnumerable{System.String},System.Globalization.CultureInfo)">
            <summary>
            Uppercases a string collection with Invariant culture. Tolerates nulls.
            </summary>
            <param name="src">Collection to lower-case</param>
            <param name="cultureInfo">Culture to use in the operation. Note that .NET's ToUpper doesn't accept a culture, so really, your only choices here are "Invariant" or "whatever .Net uses by default".</param>
            <returns>Input, lower-cased</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsStream(System.String,System.Text.Encoding)">
            <summary>
            Converts a string to a Stream of bytes with the provided encoding
            </summary>
            <param name="src">String to convert</param>
            <param name="encoding">Encoding to use</param>
            <returns>Stream or null if src is null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsString(System.Byte[])">
            <summary>
            Attempts to encode the given byte array as if it contained a
            utf8-encoded string
            </summary>
            <param name="data">Bytes to encode</param>
            <returns>The utf8 string, if possible; will return null if given null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsString(System.Byte[],System.Text.Encoding)">
            <summary>
            Attempts to encode the given byte array as if it contained a
            string encoded with the given encoding
            </summary>
            <param name="data">Bytes to encode</param>
            <param name="encoding"></param>
            <returns>The string, if possible; will return null if given null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsStream(System.Byte[])">
            <summary>
            Convenience function to wrap a given byte array in a MemoryStream.
            </summary>
            <param name="src">Bytes to wrapp</param>
            <returns>Stream wrapping the bytes or null if the source is null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsInteger(System.String)">
            <summary>
            Tests if a string represents an integer value
            </summary>
            <param name="src">String to test</param>
            <returns>True if the string can be converted to an integer; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.AsInteger(System.String)">
            <summary>
            Performs exceptionless conversion of a string to an integer
            </summary>
            <param name="value">String to convert</param>
            <returns>The integer value of the string; 0 if it cannot be converted</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsNullOrWhiteSpace(System.String)">
            <summary>
            Turns string.IsNullOrWhiteSpace into an extension method for fluency
            </summary>
            <param name="value">String to test</param>
            <returns>True if is null or whitespace; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsNullOrEmpty(System.String)">
            <summary>
            Turns string.IsNullOrEmpty into an extension method for fluency
            </summary>
            <param name="value">String to test</param>
            <returns>True if is null or whitespace; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsEmptyOrWhiteSpace(System.String)">
            <summary>
            Tests if a string is empty or all whitespace
            NB: will return false for null
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsWhiteSpace(System.String)">
            <summary>
            Tests if a string is non-empty, but made entirely of whitespace
            NB: will return false for null or empty string
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToBase64(System.String)">
            <summary>
            Returns the base64-encoded representation of a string value
            </summary>
            <param name="value">Input string value</param>
            <returns>The base64-encoded representation of the string, or null if the string is null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.LooksLikeBase64(System.String)">
            <summary>
            Returns true if the string is non-empty and contains only base64-encoding
            characters
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ZeroIfEmptyOrNull(System.String)">
            <summary>
            Returns "0" if the input string is empty or null
            </summary>
            <param name="input">String to test</param>
            <returns>Original string or "0" if empty or null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.DefaultIfEmptyOrNull(System.String,System.String)">
            <summary>
            Returns a given fallback value if the input string is whitespace or null
            </summary>
            <param name="input">String to test</param>
            <param name="fallback">Fallback value if the input is whitespace or null</param>
            <returns>Original string or the given fallback if the input is whitespace or null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.SafeTrim(System.String,System.Char[])">
            <summary>
            Safely trims a string, returning an empty string if given null
            </summary>
            <param name="input">String to trim</param>
            <param name="trimChars">Optional params of chars to trim, passed to standard String.Trim() method</param>
            <returns>Empty string if input is null, otherwise trimmed input</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToKebabCase(System.String)">
            <summary>
            Converts an input string to kebab-case
            </summary>
            <param name="input">string to convert</param>
            <returns>kebab-cased-output</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToSnakeCase(System.String)">
            <summary>
            Converts an input string to snake_case
            </summary>
            <param name="input">string to convert</param>
            <returns>snake_cased_output</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToPascalCase(System.String)">
            <summary>
            Converts an input string to PascalCase
            </summary>
            <param name="input">string to convert</param>
            <returns>
            - pascalCasedOutput => PascalCasedOutput
            - pascal-cased-output => PascalCasedOutput
            - pascal_cased_output => PascalCasedOutput
            - pascal cased output => Pascal Cased Output
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToTitleCase(System.String)">
            <summary>
            Alias for ToPascalCase
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToCamelCase(System.String)">
            <summary>
            Converts an input string to camelCase
            </summary>
            <param name="input">string to convert</param>
            <returns>camelCasedOutput</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToRandomCase(System.String)">
            <summary>
            Returns the input string in RaNdOMizEd case
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToWords(System.String)">
            <summary>
            Converts an input string to words, where possible
            eg: kebab-case => "kebab case"
                snake_case => "snake case"
                PascalCase => "pascal case"
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToLowerCasedFirstLetter(System.String)">
            <summary>
            Lower-cases the first letter in your string
            </summary>
            <param name="input">string to operate on</param>
            <returns>string with lower-cased first letter or null if input was null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToUpperCasedFirstLetter(System.String)">
            <summary>
            Upper-cases the first letter in your string
            </summary>
            <param name="input">string to operate on</param>
            <returns>string with upper-cased first letter or null if input was null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToLower(System.String,System.Globalization.CultureInfo)">
            <summary>
            Provides an in-place shum for the ToLower method
            which is used from .net framework; the latter
            can accept a CultureInfo parameter, where .net standard
            cannot, so the parameter is just dropped
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsNumeric(System.String)">
            <summary>
            Returns whether or not a string is an integer value
            </summary>
            <param name="str">string to test</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsAlphanumeric(System.String)">
            <summary>
            Tests if a string is Alphanumeric. Fails on null or whitespace too.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsAlpha(System.String)">
            <summary>
            Tests if a string is Alphabetic only. Fails on null or whitespace too.
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsNumeric(System.Char)">
            <summary>
            Tests if a character is numeric (0-9)
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.IsAlpha(System.Char)">
            <summary>
            Tests if a character is alphabetic (a-z|A-Z)
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.ToMemoryStream(System.String)">
            <summary>
            Convenience wrapper to provide a memory stream around a string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.QuoteIfSpaced(System.String)">
            <summary>
            Surrounds a string with quotes if it contains any whitespace
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.SplitCommandline(System.String)">
            <summary>
            Splits a commandline, respecting quoting
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.DeQuote(System.String)">
            <summary>
            "de-quotes" a string, only removes the outer-most, paired
            quotes, not just trimming, ie
            ""foo"" => "foo"
            "foo" => foo
            "foo => "foo
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Matches(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.StringComparison)">
            <summary>
            tests if two string collections are identical, taking into account
            the provide comparison
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="comparison"></param>
            <returns>
            true if collections are of the same size and each item, in order,
            from the left item, matches the right one
            </returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Substr(System.String,System.Int32)">
            <summary>
            Returns the substring of the given string from the given start
            Tolerates a start outside of the string - will return empty string
            Tolerates a start &lt; 0 - will start from the beginning of the string
            Tolerates null string - will return empty string
            </summary>
            <param name="str">string to operate on</param>
            <param name="start">desired starting point</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Substr(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the substring of the given string from the given start
            with the provided length
            Tolerates a start after of the string - will return empty string
            Tolerates a start &lt; 0 - will start from the beginning of the string
            Tolerates null string - will return empty string
            Tolerates a length out of bounds - will return all the string that it can
            Interprets a negative length as an offset from the end of the string
            </summary>
            <param name="str"></param>
            <param name="start"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.UnBase64(System.String)">
            <summary>
            Converts a base64 string back to the original string
            - assumes the original string is UTF8
            </summary>
            <param name="base64Data"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.UnBase64(System.String,System.Text.Encoding)">
            <summary>
            Converts a base64 string back to the original string
            using the provided encoding
            </summary>
            <param name="base64Data"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.UnBase64``1(System.String)">
            <summary>
            Quick-decode for string base64 data
            T _must_ be a string, ie var str = base64.UnBase64&lt;string&gt;()
            - assumes UTF8 encoding
            </summary>
            <param name="base64Data"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.UnBase64``1(System.String,System.Text.Encoding)">
            <summary>
            Quick-decode for string base64 data using the provided encoding
            T _must_ be a string, ie var str = base64.UnBase64&lt;string&gt;()
            </summary>
            <param name="base64Data"></param>
            <param name="encoding"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.UnBase64``1(System.String,System.Func{System.String,``0})">
            <summary>
            decode base64 string data &amp; deserialize to type T
            </summary>
            <param name="base64Data"></param>
            <param name="deserializer"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.UnBase64``1(System.String,System.Func{System.Byte[],``0})">
            <summary>
            decode base64 string data &amp; deserialize to type T
            </summary>
            <param name="base64Data"></param>
            <param name="deserializer"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.UnBase64``1(System.String,System.Func{System.String,``0},System.Text.Encoding)">
            <summary>
            decode base64 string data &amp; deserialize to type T,
            assuming that the original data in the base64 string was
            a string (eg json), using the provided encoding
            </summary>
            <param name="base64Data"></param>
            <param name="deserializer"></param>
            <param name="encoding"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Base64Padded(System.String)">
            <summary>
            Pads out a base64 string which is missing the base64 padding
            </summary>
            <param name="unpadded"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Base64UnPadded(System.String)">
            <summary>
            Removes base64 data padding (trailing '=' chars)
            - symmetrical with Base64Padded()
            </summary>
            <param name="base64Data"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Outdent(System.String)">
            <summary>
            Outdents a block to the first indentation.
            </summary>
            <param name="str">string to outdent</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Outdent(System.String,System.Int32)">
            <summary>
            Outdents a block of text at most to the given depth. Will
            stop as soon as any line is outdented completely.
            </summary>
            <param name="str">string to outdent</param>
            <param name="depth">depth to outdent to</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Outdent(System.String[],System.Int32)">
            <summary>
            Outdents a block of text at most to the given depth. Will
            stop as soon as any line is outdented completely.
            Attempts to determine the indent character from the first line with
            indenting.
            </summary>
            <param name="lines"></param>
            <param name="depth">depth to outdent to</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.StringExtensions.Outdent(System.String[],System.String,System.Int32,System.Boolean)">
            <summary>
            Outdents a block of text at most to the given depth. Will
            stop as soon as any line is outdented completely.
            </summary>
            <param name="lines"></param>
            <param name="indentedWith"></param>
            <param name="depth"></param>
            <param name="alsoTrimEnd">also right-trim lines, much like an auto-formatter would</param>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.RandomNumber">
            <summary>
            provides a singleton wrapper around Random.Next
               to reduce the chances of clashing
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.RandomNumber.Next">
            <summary>
            Wraps Random.Next
            </summary>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.RandomNumber.Next(System.Int32)">
            <summary>
            Wraps Random.Next
            </summary>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.RandomNumber.Next(System.Int32,System.Int32)">
            <summary>
            Wraps Random.Next
            </summary>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.RandomNumber.NextDouble">
            <summary>
            Wraps Random.NextDouble
            </summary>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.RandomNumber.NextBytes(System.Byte[])">
            <summary>
            Wraps Random.NextBytes
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="T:Imported.PeanutButter.Utils.Stringifier">
            <summary>
            Provides convenience functions to get reasonable string representations of objects and collections
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Stringifier.Stringify``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Provides a reasonable human-readable string representation of a collection
            </summary>
            <param name="objs"></param>
            <returns>Human-readable representation of collection</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Stringifier.Stringify(System.Object)">
            <summary>
            Provides a reasonable human-readable string representation of an object
            </summary>
            <param name="obj"></param>
            <returns>Human-readable representation of object</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.Stringifier.Stringify(System.Object,System.String)">
            <summary>
            Provides a reasonable human-readable string representation of an object
            </summary>
            <param name="obj"></param>
            <param name="nullRepresentation">How to represent null values - defaults to the string "null"</param>
            <returns>Human-readable representation of object</returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.TypeExtensions">
            <summary>
            Helper extensions for Types
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.Ancestry(System.Type)">
            <summary>
            Enumerates the ancestry of a Type
            </summary>
            <param name="type">Starting Type</param>
            <returns>The Type ancestry, starting from Object</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AncestryUntil(System.Type,System.Type)">
            <summary>
            Enumerates the ancestry of a Type, from the given type
            - if the given type is not found in the ancestry, the entire ancestry
              will be returned
            - you may provide a generic type without parameters, eg GenericBuilder&lt;,&gt;
              in which case the search is from the first occurence of that generic base type
              within the ancestry tree
            </summary>
            <param name="type">Type to operate on (final type in the result)</param>
            <param name="from">Type to truncate history at (first type in the result, when found)</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllConstants(System.Type)">
            <summary>
            Returns a dictionary of all constant values defined on a Type
            </summary>
            <param name="type">Source type to search for constants</param>
            <returns>Dictionary of constants, keyed by constant name</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllConstants``1(System.Type)">
            <summary>
            Returns a dictionary of all constant values of a specified Type found on a Type
            </summary>
            <param name="type">Type to search for constants</param>
            <typeparam name="T">Only return constants of this Type</typeparam>
            <returns>Dictionary of all constant values on a specified type</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllConstantValues(System.Type)">
            <summary>
            Returns a collection of all the constant values defined on a Type
            </summary>
            <param name="type">Type to search for constants</param>
            <returns>Collection of the constant values without their defined names</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllConstantValues``1(System.Type)">
            <summary>
            Returns a collection of all the constant values defined on a Type, restricted to the required Type T
            </summary>
            <param name="type">Type to search for constants</param>
            <typeparam name="T">Only return constants of this Type</typeparam>
            <returns>Collection of constant values from the source type which match the Type T restriction</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.HasDefaultConstructor(System.Type)">
            <summary>
            Tests if a Type has a default constructor (ie, a constructor with no parameters)
            </summary>
            <param name="type">Type to inspect</param>
            <returns>True when the type has a parameterless constructor; False otherwise. Note that a constructor with parameters which have all default values is not considered valid.</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsArrayOrAssignableFromArray(System.Type)">
            <summary>
            Tests if a type is an array or could be assigned from an array
            </summary>
            <param name="t">Type to check</param>
            <returns>True if {t} is an Array type or could have an array type assigned to it; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsEnum(System.Type)">
            <summary>
            Provides an extension method mimicking the full framework
            IsEnum for a single point of code usage
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetMethod(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetProperties(System.Type)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetProperty(System.Type,System.String)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetProperty(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetProperties(System.Type,System.Reflection.BindingFlags)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetFields(System.Type,System.Reflection.BindingFlags)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsAssignableFrom(System.Type,System.Type)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetInterfaces(System.Type)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetGenericArguments(System.Type)">
            <summary>
            provides the method normally found on a .net framework
            Type object, but reachabole on .net standard only via GetTypeInfo();
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAssembly(System.Type)">
            <summary>
            Provides an extension method mimicking the full framework
            GetAssembly for a single point of code usage
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.BaseType(System.Type)">
            <summary>
            Provides an extension method mimicking the full framework
            BaseType for a single point of code usage
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsGenericType(System.Type)">
            <summary>
            Provides an extension method mimicking the full framework
            IsGenericType for a single point of code usage
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsGenericOf(System.Type,System.Type)">
            <summary>
            Tests if a type is a generic of a given generic type (eg typeof(List&lt;&gt;))
            </summary>
            <param name="t">type to operate on</param>
            <param name="genericTest">type to test against (eg typeof(List&lt;&gt;))</param>
            <returns>True if the input type is a match, false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsAssignableFromArrayOf``1(System.Type)">
            <summary>
            Tests if a type is assignable from an array of T
            </summary>
            <param name="t">Type to test</param>
            <typeparam name="T">Item type of array which calling code would like to assign</typeparam>
            <returns>True if the parameter type is assignable from an array of T</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.ImplementsEnumerableGenericType(System.Type)">
            <summary>
            Tests if a type implements IEnumerable&lt;&gt;
            </summary>
            <param name="t">Type to test</param>
            <returns>True if the source type implements IEnumerable&lt;&gt;; False otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.ImplementsIDictionaryGenericType(System.Type)">
            <summary>
            Returns true if the provided type implements IDictionary&lt;,&gt;
            anywhere in the type heirachy
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsIDictionary(System.Type)">
            <summary>
            Returns true if a type directly implements IDictionary&lt;,&gt;
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.TryGetDictionaryKeyAndValueTypes(System.Type,System.Type@,System.Type@)">
            <summary>
            Tries to get the key and value types for an object, if
            it implements IDictionary&lt;TKey,TValue&gt;. Returns true
            if sucessful (with the out parameters set) or false if
            the provided type does not implement IDictionary&lt;,&gt;
            </summary>
            <param name="type"></param>
            <param name="keyType"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.TryGetEnumerableInterface(System.Type)">
            <summary>
            Attempts to get the implemented Generic IEnumerable interface for a type, if possible
            </summary>
            <param name="srcType">Type to search for the interface</param>
            <returns>Generic IEnumerable type implemented if found or null otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.TryGetEnumerableItemType(System.Type)">
            <summary>
            Attempts to get the item type (T)
            for a Type which is assumed to implement IEnumerable&lt;T&gt;
            </summary>
            <param name="srcType">Type to search for the IEnumerable &lt;T&gt; interface and underlying type</param>
            <returns>IEnumerable&lt;&gt; item type (T) implemented if found or null otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsGenericOfIEnumerable(System.Type)">
            <summary>
            Tests if a type directly implements the generic IEnumerable interface
            </summary>
            <param name="arg">Type to test</param>
            <returns>True if it does implement the generic IEnumerable; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetCollectionItemType(System.Type)">
            <summary>
            Attempts to get the item type of a collection
            </summary>
            <param name="collectionType">Type to inspect</param>
            <returns>Item type, if it can be found, or null</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetAllImplementedInterfaces(System.Type)">
            <summary>
            Attempts to find all implemented interfaces (and inherited ones) for a Type
            </summary>
            <param name="inspectType">Type to inspect</param>
            <returns>Array of all interfaces which are implemented</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsDisposable(System.Type)">
            <summary>
            Tests if a type implements IDisposable
            </summary>
            <param name="t">Type to test</param>
            <returns>True if it implements IDisposable; false otherwise</returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.PrettyName(System.Type)">
            <summary>
            Provides a "pretty" name for a type, taking into account
            generics and nullable types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsCollection(System.Type)">
            <summary>
            Rudimentary test for if a type is a collection type, testing for
            IEnumerable&lt;&gt; interface implementation as well as some baked-in
            known generic types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.CanBeAssignedNull(System.Type)">
            <summary>
            Determines if an object of this type can be assigned null
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsValueType(System.Type)">
            <summary>
            Provides single method to determine IsValueType (shimmed for NETSTANDARD)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsAssignableOrUpCastableTo(System.Type,System.Type)">
            <summary>
            Returns true if the type being operated on can be directly assigned
            or implicitly upcast to the target type
            </summary>
            <param name="src"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.CanImplicitlyCastTo(System.Type,System.Type)">
            <summary>
            Returns true if the type being operated on can be
            implicitly upcast to the target type
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.TryImplicitlyCastTo(System.Object,System.Type,System.Object@)">
            <summary>
            Returns true if the type being operated on can be
            implicitly upcast to the target type (value types only, so far)
            </summary>
            <param name="targetType"></param>
            <param name="srcValue"></param>
            <param name="castValue"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.DefaultValue(System.Type)">
            <summary>
            Returns the default value for the type being operated on
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsInterface(System.Type)">
            <summary>
            Cross-target shim for the IsInterface property,
            found on Type in NetFramework and on Type.GetTypeInf()
            on NETSTANDARD
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsNumericType(System.Type)">
            <summary>
            Determines whether the provided type is a known numeric type
            (ie int / short / byte / double / float / decimal )
            </summary>
            <param name="type">Type to operate on</param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsAncestorOf(System.Type,System.Type)">
            <summary>
            Determines whether the type being operated on is an ancestor of the other type
            ie typeof(object).IsAncestorOf(typeof(Foo)) => true
            </summary>
            <param name="type"></param>
            <param name="test"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.Inherits(System.Type,System.Type)">
            <summary>
            Returns true when the type being operated on inherits from the test type, ie
            typeof(Foo).Inherits(typeof(object)) => true
            </summary>
            <param name="type"></param>
            <param name="test"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.Implements``1(System.Type)">
            <summary>
            Tests if the type being operated on implements the provided interfaceType
            </summary>
            <param name="type"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            Tests if the type being operated on implements the provided interfaceType
            </summary>
            <param name="type"></param>
            <param name="interfaceType"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AllPublicInstancePropertiesAndMethodsAreVirtualOrAbstractAndNonFinal(System.Type)">
            <summary>
            Tests if all public instance properties and methods are virtual or abstract
            _and_ non-final (ie, can be mimicked with a duck)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AllPublicInstancePropertiesAndMethodsAreNonFinal(System.Type)">
            <summary>
            Tests if all public instance properties and methods are non-final
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AllPublicInstanceMethodsAreNonFinal(System.Type)">
            <summary>
            Tests if all public instance methods are non-final
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AllPublicInstancePropertiesAreNonFinal(System.Type)">
            <summary>
            Tests if all public instance properties are non-final
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AllPublicInstancePropertiesAndMethodsAreVirtualOrAbstract(System.Type)">
            <summary>
            Returns true if all public properties and methods are either virtual or abstract\
            (ie can be properly overridden)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AllPublicInstancePropertiesAreVirtualOrAbstract(System.Type)">
            <summary>
            Returns true if all instance properties on the provided type are
            either virtual or abstract (ie, overridable)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.AllPublicInstanceMethodsAreVirtualOrAbstract(System.Type)">
            <summary>
            Returns true if all instance methods on the provided type are
            either virtual or abstract (ie, overridable)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetTopMostPropertyValue``1(System.Object,System.String)">
            <summary>
            Retrieves the value of the "top-most" property in an inheritance hierarchy
            which matches the given name and type
            </summary>
            <param name="data"></param>
            <param name="propertyName"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.SetTopMostProperty``1(System.Object,System.String,``0)">
            <summary>
            Sets the "top-most" property in an ancestry, useful for setting
            properties marked as "new" when you have access to the object
            cast to an ancestor type
            </summary>
            <param name="data"></param>
            <param name="propertyName"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsVirtualOrAbstract(System.Reflection.MethodInfo)">
            <summary>
            returns true if the given method is virtual or abstract
            </summary>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsConcrete(System.Type)">
            <summary>
            returns true if the type is not an interface or an abstract type
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsVirtualOrAbstract(System.Reflection.PropertyInfo)">
            <summary>
            returns true if the given property is virtual or abstract
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsFinal(System.Reflection.PropertyInfo)">
            <summary>
            returns true if the property is marked as IsFinal
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.Implements``1(``0,System.Type)">
            <summary>
            returns true if the provided object implements the expected interface
            </summary>
            <param name="obj"></param>
            <param name="expected"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsNullableType(System.Type)">
            <summary>
            Tests if the provided type is nullable
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.SetStatic``1(System.Type,System.String,``0)">
            <summary>
            Attempts to set a static property or field value
            </summary>
            <param name="t"></param>
            <param name="fieldOrPropertyName"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.GetStatic``1(System.Type,System.String)">
            <summary>
            Attempts to get a static property or field value
            </summary>
            <param name="t"></param>
            <param name="fieldOrPropertyName"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.IsPrimitiveOrImmutable(System.Type)">
            <summary>
            Tests if the provided type is a "proper" primitive or
            some other built-in immutable type, eg DateTime, TimeSpan,
            Guid, DateTimeOffset
            - useful when performing recursive reflection - if you hit
              a type identified by this extension method, then you should
              probably stop recursing.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.ResolveNullableUnderlyingType(System.Type)">
            <summary>
            Resolves to the actual type or the underlying type T if the provided
            type is Nullable&lt;T&gt;
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Imported.PeanutButter.Utils.TypeExtensions.HasAttribute``1(System.Type)">
            <summary>
            Tests if a provided type is decorated with the expected attribute [TAttribute]
            </summary>
            <param name="type"></param>
            <typeparam name="TAttribute"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Imported.PeanutButter.Utils.CannotZipNullException">
            <summary>
            Thrown when an attempt is made to strict-zip null and anything else
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.CannotZipNullException.#ctor">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.UnevenZipException">
            <summary>
            Thrown when an attempt is made to zip two collections of
            uneven size
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.UnevenZipException.#ctor">
            <inheritdoc />
        </member>
        <member name="T:Imported.PeanutButter.Utils.UnevenZipException`2">
            <summary>
            Thrown when an attempt is made to zip two collections of
            uneven size. Also includes references to the two collections.
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.UnevenZipException`2.Left">
            <summary>
            The left collection
            </summary>
        </member>
        <member name="P:Imported.PeanutButter.Utils.UnevenZipException`2.Right">
            <summary>
            The right collection
            </summary>
        </member>
        <member name="M:Imported.PeanutButter.Utils.UnevenZipException`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc />
        </member>
    </members>
</doc>
